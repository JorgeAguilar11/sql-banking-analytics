# üéØ Gu√≠a Pr√°ctica: SQL Avanzado con Agregaciones Bancarias

## üìã **Introducci√≥n**
Esta gu√≠a pr√°ctica te acompa√±ar√° paso a paso para dominar las agregaciones SQL en el contexto bancario. Cada secci√≥n incluye ejercicios progresivos, casos reales y validaciones.

---

## üõ†Ô∏è **Configuraci√≥n Inicial**

### **üìÅ Estructura de Trabajo**
```
notebooks/02_agregaciones_groupby/
‚îú‚îÄ‚îÄ agregaciones_groupby_bancario.ipynb    # Tutorial principal
‚îú‚îÄ‚îÄ GUIA_TEORIA_AGREGACIONES.md           # Base te√≥rica
‚îú‚îÄ‚îÄ GUIA_PRACTICA_SQL_AVANZADO.md         # Esta gu√≠a pr√°ctica
‚îú‚îÄ‚îÄ EJERCICIOS_PRACTICOS.md               # Retos adicionales
‚îú‚îÄ‚îÄ practica_sql_avanzada.py              # Scripts automatizados
‚îî‚îÄ‚îÄ README.md                             # Navegaci√≥n del m√≥dulo
```

### **üöÄ Preparaci√≥n del Entorno**
```bash
# 1. Activar entorno virtual
source ../../venv_banking_sql/bin/activate

# 2. Verificar base de datos
ls -la ../../data/banking_core.db

# 3. Abrir notebook principal
jupyter notebook agregaciones_groupby_bancario.ipynb
```

---

## üî¢ **Nivel 1: Funciones de Agregaci√≥n B√°sicas**

### **üéØ Objetivo**: Dominar COUNT, SUM, AVG, MAX, MIN

### **Ejercicio 1.1: Explorando Conteos**
```sql
-- Pr√°ctica b√°sica con COUNT
SELECT COUNT(*) as total_registros FROM clientes;
SELECT COUNT(DISTINCT segmento_cliente) as segmentos_unicos FROM clientes;
SELECT COUNT(ingresos_mensuales) as clientes_con_ingresos FROM clientes;
```

**üí° Punto clave**: `COUNT(*)` cuenta todas las filas, `COUNT(columna)` excluye NULLs.

### **Ejercicio 1.2: Sumando Valores Monetarios**
```sql
-- Saldos totales por estado de cuenta
SELECT 
    estado,
    COUNT(*) as numero_cuentas,
    SUM(saldo_actual) as saldo_total,
    SUM(CASE WHEN saldo_actual > 1000000 THEN saldo_actual ELSE 0 END) as saldo_premium
FROM cuentas
GROUP BY estado;
```

**üéØ Validaci√≥n**: El saldo total debe cuadrar con la suma de todos los saldos individuales.

### **Ejercicio 1.3: Calculando Promedios Inteligentes**
```sql
-- Promedios por segmento con an√°lisis de dispersi√≥n
SELECT 
    segmento_cliente,
    COUNT(*) as cantidad_clientes,
    AVG(ingresos_mensuales) as ingreso_promedio,
    MIN(ingresos_mensuales) as ingreso_minimo,
    MAX(ingresos_mensuales) as ingreso_maximo,
    MAX(ingresos_mensuales) - MIN(ingresos_mensuales) as rango_ingresos
FROM clientes
WHERE estado = 'ACTIVO' AND ingresos_mensuales IS NOT NULL
GROUP BY segmento_cliente
ORDER BY ingreso_promedio DESC;
```

**üìä Insight**: Un rango amplio indica mayor heterogeneidad en el segmento.

---

## üìà **Nivel 2: GROUP BY Progresivo**

### **üéØ Objetivo**: Agrupar datos para generar insights de negocio

### **Ejercicio 2.1: Agrupaci√≥n Simple con Ranking**
```sql
-- Top productos por n√∫mero de cuentas
SELECT 
    pf.categoria,
    pf.nombre_producto,
    COUNT(c.cuenta_id) as total_cuentas,
    RANK() OVER (ORDER BY COUNT(c.cuenta_id) DESC) as ranking_popularidad
FROM productos_financieros pf
LEFT JOIN cuentas c ON pf.producto_id = c.producto_id AND c.estado = 'ACTIVA'
GROUP BY pf.categoria, pf.nombre_producto
ORDER BY total_cuentas DESC;
```

**üíº Aplicaci√≥n**: Identifica productos estrella y oportunidades de mejora.

### **Ejercicio 2.2: Agrupaci√≥n M√∫ltiple con Subtotales**
```sql
-- An√°lisis por segmento y categor√≠a de producto
SELECT 
    COALESCE(cl.segmento_cliente, 'TOTAL GENERAL') as segmento,
    COALESCE(pf.categoria, 'TOTAL SEGMENTO') as categoria_producto,
    COUNT(DISTINCT cl.cliente_id) as clientes_unicos,
    COUNT(c.cuenta_id) as total_cuentas,
    SUM(c.saldo_actual) as saldo_total,
    AVG(c.saldo_actual) as saldo_promedio
FROM clientes cl
JOIN cuentas c ON cl.cliente_id = c.cliente_id
JOIN productos_financieros pf ON c.producto_id = pf.producto_id
WHERE cl.estado = 'ACTIVO' AND c.estado = 'ACTIVA'
GROUP BY ROLLUP(cl.segmento_cliente, pf.categoria)
ORDER BY segmento, categoria_producto;
```

**üîç Nota**: `ROLLUP` genera subtotales autom√°ticamente.

### **Ejercicio 2.3: Segmentaci√≥n Din√°mica**
```sql
-- Crear segmentos por comportamiento de saldo
SELECT 
    CASE 
        WHEN AVG(saldo_actual) < 500000 THEN 'B√°sico'
        WHEN AVG(saldo_actual) < 2000000 THEN 'Intermedio'
        WHEN AVG(saldo_actual) < 5000000 THEN 'Premium'
        ELSE 'VIP'
    END as segmento_comportamiento,
    COUNT(DISTINCT cliente_id) as cantidad_clientes,
    MIN(AVG(saldo_actual)) as saldo_min_promedio,
    MAX(AVG(saldo_actual)) as saldo_max_promedio
FROM (
    SELECT 
        cl.cliente_id,
        AVG(c.saldo_actual) as saldo_actual
    FROM clientes cl
    JOIN cuentas c ON cl.cliente_id = c.cliente_id
    WHERE cl.estado = 'ACTIVO' AND c.estado = 'ACTIVA'
    GROUP BY cl.cliente_id
) cliente_promedio
GROUP BY segmento_comportamiento
ORDER BY saldo_min_promedio;
```

**üéØ Insight**: Segmentaci√≥n basada en comportamiento real vs. datos demogr√°ficos.

---

## üîç **Nivel 3: HAVING Estrat√©gico**

### **üéØ Objetivo**: Filtrar grupos para identificar patrones cr√≠ticos

### **Ejercicio 3.1: Identificando Outliers**
```sql
-- Clientes con comportamiento at√≠pico
SELECT 
    cl.cliente_id,
    cl.nombre || ' ' || cl.apellidos as nombre_completo,
    cl.segmento_cliente,
    COUNT(c.cuenta_id) as numero_cuentas,
    SUM(c.saldo_actual) as saldo_total_cliente,
    AVG(c.saldo_actual) as saldo_promedio_cliente
FROM clientes cl
JOIN cuentas c ON cl.cliente_id = c.cliente_id
WHERE cl.estado = 'ACTIVO' AND c.estado = 'ACTIVA'
GROUP BY cl.cliente_id, cl.nombre, cl.apellidos, cl.segmento_cliente
HAVING COUNT(c.cuenta_id) > 5  -- M√°s de 5 cuentas
   OR SUM(c.saldo_actual) > 50000000  -- Saldo total > $50M
   OR (COUNT(c.cuenta_id) = 1 AND SUM(c.saldo_actual) > 10000000)  -- Cuenta √∫nica con > $10M
ORDER BY saldo_total_cliente DESC;
```

**‚ö†Ô∏è Objetivo**: Identificar clientes que requieren atenci√≥n especial.

### **Ejercicio 3.2: Alertas de Concentraci√≥n**
```sql
-- Productos con alta concentraci√≥n de riesgo
SELECT 
    pf.categoria,
    pf.nombre_producto,
    COUNT(c.cuenta_id) as numero_cuentas,
    SUM(c.saldo_actual) as saldo_total,
    AVG(c.saldo_actual) as saldo_promedio,
    MAX(c.saldo_actual) as saldo_maximo,
    ROUND(MAX(c.saldo_actual) * 100.0 / SUM(c.saldo_actual), 2) as concentracion_max_cliente
FROM productos_financieros pf
JOIN cuentas c ON pf.producto_id = c.producto_id
WHERE c.estado = 'ACTIVA'
GROUP BY pf.categoria, pf.nombre_producto
HAVING COUNT(c.cuenta_id) >= 10  -- Productos significativos
   AND MAX(c.saldo_actual) * 100.0 / SUM(c.saldo_actual) > 25  -- Concentraci√≥n > 25%
ORDER BY concentracion_max_cliente DESC;
```

**üìä KPI**: Concentraci√≥n alta indica riesgo de dependencia de un cliente.

### **Ejercicio 3.3: An√°lisis de Crecimiento**
```sql
-- Productos con crecimiento acelerado (√∫ltimos 6 meses)
SELECT 
    pf.categoria,
    COUNT(c.cuenta_id) as cuentas_nuevas,
    SUM(c.saldo_actual) as saldo_total_nuevas,
    AVG(c.saldo_actual) as saldo_promedio_nuevas
FROM productos_financieros pf
JOIN cuentas c ON pf.producto_id = c.producto_id
WHERE c.estado = 'ACTIVA' 
  AND c.fecha_apertura >= date('now', '-6 months')
GROUP BY pf.categoria
HAVING COUNT(c.cuenta_id) > 20  -- Al menos 20 cuentas nuevas
   AND AVG(c.saldo_actual) > 1000000  -- Saldo promedio > $1M
ORDER BY cuentas_nuevas DESC;
```

**üìà Objetivo**: Identificar productos con momentum positivo.

---

## üíº **Nivel 4: KPIs Bancarios Avanzados**

### **üéØ Objetivo**: Crear m√©tricas de negocio estrat√©gicas

### **Ejercicio 4.1: √çndice de Penetraci√≥n de Productos**
```sql
-- Calculando penetraci√≥n de cada producto en la base de clientes
WITH clientes_activos AS (
    SELECT COUNT(*) as total_clientes FROM clientes WHERE estado = 'ACTIVO'
),
penetracion_productos AS (
    SELECT 
        pf.categoria,
        pf.nombre_producto,
        COUNT(DISTINCT c.cliente_id) as clientes_con_producto,
        ca.total_clientes,
        ROUND(COUNT(DISTINCT c.cliente_id) * 100.0 / ca.total_clientes, 2) as penetracion_porcentaje
    FROM productos_financieros pf
    LEFT JOIN cuentas c ON pf.producto_id = c.producto_id AND c.estado = 'ACTIVA'
    CROSS JOIN clientes_activos ca
    GROUP BY pf.categoria, pf.nombre_producto, ca.total_clientes
)
SELECT 
    categoria,
    nombre_producto,
    clientes_con_producto,
    total_clientes,
    penetracion_porcentaje,
    CASE 
        WHEN penetracion_porcentaje > 50 THEN 'Alto'
        WHEN penetracion_porcentaje > 20 THEN 'Medio'
        ELSE 'Bajo'
    END as nivel_penetracion
FROM penetracion_productos
ORDER BY penetracion_porcentaje DESC;
```

**üí° Insight**: Alta penetraci√≥n = producto exitoso, baja = oportunidad de crecimiento.

### **Ejercicio 4.2: An√°lisis de Valor del Cliente (CLV)**
```sql
-- Calculando el valor de vida del cliente por segmento
SELECT 
    cl.segmento_cliente,
    COUNT(DISTINCT cl.cliente_id) as total_clientes,
    SUM(c.saldo_actual) as valor_total_segmento,
    AVG(c.saldo_actual) as valor_promedio_por_cuenta,
    SUM(c.saldo_actual) / COUNT(DISTINCT cl.cliente_id) as valor_promedio_por_cliente,
    COUNT(c.cuenta_id) / COUNT(DISTINCT cl.cliente_id) as cuentas_promedio_por_cliente,
    -- Estimaci√≥n de valor anual (asumiendo 2% comisi√≥n)
    ROUND(SUM(c.saldo_actual) * 0.02, 2) as ingresos_estimados_anuales
FROM clientes cl
LEFT JOIN cuentas c ON cl.cliente_id = c.cliente_id AND c.estado = 'ACTIVA'
WHERE cl.estado = 'ACTIVO'
GROUP BY cl.segmento_cliente
ORDER BY valor_promedio_por_cliente DESC;
```

**üí∞ Objetivo**: Priorizar esfuerzos de retenci√≥n y adquisici√≥n.

### **Ejercicio 4.3: Matriz de Productos (Boston Consulting Group)**
```sql
-- Clasificaci√≥n de productos: Estrellas, Vacas lecheras, Interrogantes, Perros
WITH metricas_productos AS (
    SELECT 
        pf.categoria,
        pf.nombre_producto,
        COUNT(c.cuenta_id) as numero_cuentas,
        SUM(c.saldo_actual) as saldo_total,
        AVG(c.saldo_actual) as saldo_promedio,
        -- Crecimiento (cuentas √∫ltimos 6 meses vs total)
        COUNT(CASE WHEN c.fecha_apertura >= date('now', '-6 months') THEN 1 END) * 100.0 / 
        NULLIF(COUNT(c.cuenta_id), 0) as tasa_crecimiento_6m
    FROM productos_financieros pf
    LEFT JOIN cuentas c ON pf.producto_id = c.producto_id AND c.estado = 'ACTIVA'
    GROUP BY pf.categoria, pf.nombre_producto
),
clasificacion AS (
    SELECT *,
        -- Cuadrantes BCG
        CASE 
            WHEN saldo_total > (SELECT AVG(saldo_total) FROM metricas_productos) 
             AND tasa_crecimiento_6m > (SELECT AVG(tasa_crecimiento_6m) FROM metricas_productos) 
            THEN '‚≠ê Estrella'
            WHEN saldo_total > (SELECT AVG(saldo_total) FROM metricas_productos) 
             AND tasa_crecimiento_6m <= (SELECT AVG(tasa_crecimiento_6m) FROM metricas_productos) 
            THEN 'üêÑ Vaca Lechera'
            WHEN saldo_total <= (SELECT AVG(saldo_total) FROM metricas_productos) 
             AND tasa_crecimiento_6m > (SELECT AVG(tasa_crecimiento_6m) FROM metricas_productos) 
            THEN '‚ùì Interrogante'
            ELSE 'üêï Perro'
        END as clasificacion_bcg
    FROM metricas_productos
    WHERE numero_cuentas > 0
)
SELECT 
    clasificacion_bcg,
    COUNT(*) as cantidad_productos,
    SUM(saldo_total) as saldo_total_categoria,
    AVG(tasa_crecimiento_6m) as crecimiento_promedio
FROM clasificacion
GROUP BY clasificacion_bcg
ORDER BY saldo_total_categoria DESC;
```

**üéØ Estrategia**: 
- ‚≠ê Estrellas: Invertir m√°s
- üêÑ Vacas lecheras: Mantener y optimizar
- ‚ùì Interrogantes: Evaluar potencial
- üêï Perros: Considerar descontinuar

---

## üìÖ **Nivel 5: An√°lisis Temporal Avanzado**

### **üéØ Objetivo**: Identificar tendencias y estacionalidad

### **Ejercicio 5.1: An√°lisis de Tendencia Mensual**
```sql
-- Evoluci√≥n mensual de apertura de cuentas y saldos
SELECT 
    strftime('%Y', fecha_apertura) as a√±o,
    strftime('%m', fecha_apertura) as mes,
    COUNT(*) as cuentas_abiertas,
    SUM(saldo_actual) as saldo_inicial_total,
    AVG(saldo_actual) as saldo_inicial_promedio,
    -- Comparaci√≥n con mes anterior
    LAG(COUNT(*)) OVER (ORDER BY strftime('%Y-%m', fecha_apertura)) as cuentas_mes_anterior,
    COUNT(*) - LAG(COUNT(*)) OVER (ORDER BY strftime('%Y-%m', fecha_apertura)) as variacion_cuentas
FROM cuentas
WHERE fecha_apertura >= date('now', '-24 months')
  AND fecha_apertura IS NOT NULL
GROUP BY strftime('%Y', fecha_apertura), strftime('%m', fecha_apertura)
ORDER BY a√±o DESC, mes DESC;
```

**üìà Insight**: Identifica estacionalidad y tendencias de crecimiento.

### **Ejercicio 5.2: Cohorte de Clientes por Per√≠odo de Ingreso**
```sql
-- An√°lisis de retenci√≥n por cohorte de ingreso
WITH cohortes AS (
    SELECT 
        strftime('%Y-%m', fecha_registro) as periodo_ingreso,
        COUNT(DISTINCT cliente_id) as clientes_iniciales,
        COUNT(DISTINCT CASE WHEN estado = 'ACTIVO' THEN cliente_id END) as clientes_activos_actuales,
        ROUND(COUNT(DISTINCT CASE WHEN estado = 'ACTIVO' THEN cliente_id END) * 100.0 / 
              COUNT(DISTINCT cliente_id), 2) as tasa_retencion
    FROM clientes
    WHERE fecha_registro >= date('now', '-36 months')
    GROUP BY strftime('%Y-%m', fecha_registro)
),
con_saldos AS (
    SELECT 
        c.*,
        COALESCE(SUM(cu.saldo_actual), 0) as saldo_total_cohorte,
        COALESCE(AVG(cu.saldo_actual), 0) as saldo_promedio_cohorte
    FROM cohortes c
    LEFT JOIN clientes cl ON strftime('%Y-%m', cl.fecha_registro) = c.periodo_ingreso AND cl.estado = 'ACTIVO'
    LEFT JOIN cuentas cu ON cl.cliente_id = cu.cliente_id AND cu.estado = 'ACTIVA'
    GROUP BY c.periodo_ingreso, c.clientes_iniciales, c.clientes_activos_actuales, c.tasa_retencion
)
SELECT 
    periodo_ingreso,
    clientes_iniciales,
    clientes_activos_actuales,
    tasa_retencion,
    saldo_total_cohorte,
    saldo_promedio_cohorte,
    CASE 
        WHEN tasa_retencion > 80 THEN 'üü¢ Excelente'
        WHEN tasa_retencion > 60 THEN 'üü° Buena'
        WHEN tasa_retencion > 40 THEN 'üü† Regular'
        ELSE 'üî¥ Deficiente'
    END as evaluacion_retencion
FROM con_saldos
ORDER BY periodo_ingreso DESC;
```

**üîÑ Objetivo**: Medir la efectividad de estrategias de retenci√≥n.

---

## üéØ **EJERCICIOS COMPLETADOS - TUS LOGROS**

### **‚úÖ Resumen de Tu Progreso**
Has completado exitosamente **6 ejercicios avanzados** (7-12) con consultas SQL profesionales. Aqu√≠ est√°n documentadas todas tus soluciones con resultados reales:

---

### **üí∞ EJERCICIO 7: Promedio de Ingresos por Ciudad** ‚úÖ
**üéØ Objetivo**: Calcular el promedio de ingresos por ciudad usando `AVG()`

```sql
SELECT 
    ciudad,
    COUNT(*) AS total_clientes,
    AVG(ingresos_mensuales) AS promedio_ingresos
FROM 
    clientes
WHERE 
    ingresos_mensuales IS NOT NULL
GROUP BY 
    ciudad
ORDER BY 
    promedio_ingresos DESC;
```

**üìä Resultados Obtenidos**:
- **Barranquilla**: 2 clientes, promedio $6,468,453
- **Bucaramanga**: 6 clientes, promedio $6,445,098  
- **Medell√≠n**: 6 clientes, promedio $6,413,412
- **Bogot√°**: 3 clientes, promedio $4,751,162
- **Cali**: 3 clientes, promedio $3,338,088

**üìù Conceptos Aplicados**:
- ‚úÖ Funci√≥n `AVG()` para calcular promedios
- ‚úÖ Combinaci√≥n de `COUNT()` y `AVG()` en una consulta
- ‚úÖ Manejo de valores NULL con `WHERE IS NOT NULL`
- ‚úÖ Ordenamiento por promedio descendente

---

### **üèÜ EJERCICIO 8: Top 3 Clientes M√°s Ricos** ‚úÖ
**üéØ Objetivo**: Identificar los 3 clientes con mayores ingresos usando `LIMIT`

```sql
SELECT 
    nombres || ' ' || apellidos AS nombre_completo,
    ingresos_mensuales,
    ciudad
FROM clientes 
ORDER BY ingresos_mensuales DESC
LIMIT 3;
```

**üìä Resultados Obtenidos**:
1. **Isabella Jim√©nez** (Bucaramanga) - $11,060,983
2. **Pedro Morales** (Medell√≠n) - $10,330,811
3. **Sofia Rivera** (Bucaramanga) - $9,834,891

**üìù Conceptos Aplicados**:
- ‚úÖ Concatenaci√≥n de campos con `||`
- ‚úÖ Uso de `LIMIT` para Top N consultas
- ‚úÖ Identificaci√≥n de clientes VIP
- ‚úÖ Ordenamiento para rankings

---

### **üè† EJERCICIO 9: Clientes de Clase Media** ‚úÖ
**üéØ Objetivo**: Filtrar clientes con ingresos entre 3M-7M usando `BETWEEN`

```sql
SELECT 
    cliente_id,
    nombres,
    apellidos,
    ciudad,
    ingresos_mensuales
FROM 
    clientes
WHERE 
    ingresos_mensuales BETWEEN 3000000 AND 7000000
ORDER BY 
    ingresos_mensuales DESC;
```

**üìä Resultados Obtenidos**:
- **Total encontrados**: 10 clientes (50% del total)
- **Rango de ingresos**: $3,058,931 - $6,377,879
- **Ciudad l√≠der**: Medell√≠n y Bogot√° con 3 clientes cada una

**üìù Conceptos Aplicados**:
- ‚úÖ Operador `BETWEEN` para rangos num√©ricos
- ‚úÖ Segmentaci√≥n de clientes por ingresos
- ‚úÖ An√°lisis de clase media bancaria
- ‚úÖ Filtrado por criterios de negocio

---

### **üìä EJERCICIO 10: Distribuci√≥n por Segmentos** ‚úÖ
**üéØ Objetivo**: Contar clientes por cada segmento usando `GROUP BY`

```sql
SELECT 
    segmento_cliente,
    COUNT(*) AS cantidad_clientes
FROM 
    clientes
WHERE 
    segmento_cliente IS NOT NULL
GROUP BY 
    segmento_cliente
ORDER BY 
    cantidad_clientes DESC;
```

**üìä Resultados Obtenidos**:
- **Est√°ndar**: 8 clientes (40%)
- **VIP**: 5 clientes (25%)  
- **Premium**: 5 clientes (25%)
- **B√°sico**: 2 clientes (10%)

**üìù Conceptos Aplicados**:
- ‚úÖ An√°lisis de distribuci√≥n de segmentos
- ‚úÖ Agrupaci√≥n por categor√≠as de clientes
- ‚úÖ Estrategia de marketing por segmentos
- ‚úÖ Filtrado de valores NULL

---

### **üèÖ EJERCICIO 11: Ciudad con Mayor Suma Total** ‚úÖ
**üéØ Objetivo**: Encontrar la ciudad m√°s valiosa usando `SUM()` y `LIMIT`

```sql
SELECT 
    ciudad,
    SUM(ingresos_mensuales) AS ingresos_totales
FROM 
    clientes
WHERE 
    ingresos_mensuales IS NOT NULL
GROUP BY 
    ciudad
ORDER BY 
    ingresos_totales DESC
LIMIT 1;
```

**üìä Resultado Obtenido**:
- **üèÜ GANADORA**: **Bucaramanga** con $38,670,590 en ingresos totales

**üìù Conceptos Aplicados**:
- ‚úÖ Funci√≥n `SUM()` para totales acumulados
- ‚úÖ Identificaci√≥n de mercados m√°s valiosos
- ‚úÖ An√°lisis territorial de ingresos
- ‚úÖ Combinaci√≥n de `SUM()`, `GROUP BY` y `LIMIT`

---

### **üíé EJERCICIO 12: Porcentaje VIP por Ciudad** ‚úÖ
**üéØ Objetivo**: Calcular porcentajes usando `CASE WHEN` avanzado

```sql
SELECT 
    ciudad,
    COUNT(*) AS total_clientes,
    SUM(CASE WHEN segmento_cliente = 'VIP' THEN 1 ELSE 0 END) AS clientes_vip,
    ROUND(
        100.0 * SUM(CASE WHEN segmento_cliente = 'VIP' THEN 1 ELSE 0 END) / COUNT(*),
        2
    ) AS porcentaje_vip
FROM clientes
GROUP BY ciudad
ORDER BY porcentaje_vip DESC;
```

**üìä Resultados Obtenidos**:
- **Bucaramanga**: 6 clientes, 3 VIP (50.00%)
- **Medell√≠n**: 6 clientes, 2 VIP (33.33%)
- **Cali**: 3 clientes, 0 VIP (0.00%)
- **Bogot√°**: 3 clientes, 0 VIP (0.00%)
- **Barranquilla**: 2 clientes, 0 VIP (0.00%)

**üìù Conceptos Aplicados**:
- ‚úÖ Expresiones condicionales `CASE WHEN`
- ‚úÖ C√°lculo de porcentajes en SQL
- ‚úÖ Funci√≥n `ROUND()` para decimales
- ‚úÖ An√°lisis VIP por territorio
- ‚úÖ L√≥gica condicional avanzada

---

## üéØ **INSIGHTS CLAVE DESCUBIERTOS**

### **üèÜ Principales Hallazgos**:
1. **Ciudad l√≠der**: **Bucaramanga** domina en:
   - Mayor suma total de ingresos ($38.67M)
   - Mayor porcentaje de clientes VIP (50%)
   - Concentra 2 de los 3 clientes m√°s ricos

2. **Segmentaci√≥n de mercado**:
   - 40% de clientes son **Est√°ndar** (mayor√≠a)
   - 25% cada uno en **VIP** y **Premium**
   - Solo 10% en segmento **B√°sico**

3. **Oportunidades de negocio**:
   - **Clase media**: 50% de clientes (3M-7M) representa gran potencial
   - **Cali y Bogot√°**: Sin clientes VIP, oportunidad de growth
   - **Barranquilla**: Mejor promedio por cliente pero pocos clientes

### **üìä M√©tricas Bancarias Calculadas**:
- **Concentraci√≥n VIP**: 25% de clientes genera el mayor valor
- **Distribuci√≥n territorial**: Desbalanceada, Bucaramanga concentra valor
- **Potencial de crecimiento**: Ciudades sin VIP son oportunidad

---
